/**
 * Modified form of `src/logger.ts` from
 * [gistpad extension](https://github.com/vsls-contrib/gistpad/)
 */

//#region Imports

import * as vscode from "vscode";
import { window } from "vscode";

import { bind } from 'helpful-decorators';

import { OUTPUT, META, DEBUG } from './constants'
import Settings from './settings'
import is from './guard'

//#endregion Imports

//#region Declarations

const enum LogTypes
{
    'info'   = 'info',
    'warn'   = 'warning',
    'error'  = 'error',
    'debug'  = 'debug'
}
type        LogType    = keyof typeof LogTypes
type        LogOptions = typeof LogTypes[LogMethods]
export type LogMethods = LogType

interface ILogger extends Record<LogMethods, (message: string) => void> { }

/**
 * Generated by `Logger#extend`
 */
interface LoggerExtend extends Logger
{
    (msg: string): void
}

interface TaggedLogProperties
{
    level:             LogType;
    prefixes:          string[];
    prefixTransform(): string;
}

type TaggedLogFunction =  (msg: string) => void

type TaggedLog =
    & TaggedLogFunction
    & TaggedLogProperties


//#endregion Declarations

//#region Defaults

const defaultChannel = window.createOutputChannel(OUTPUT.CHANNEL.NAME)
console.debug(`[${META.EXTENSION.NAME}] Created output channel ${OUTPUT.CHANNEL.NAME}`)

//#endregion Defaults

//#region Utils

/**
 * Returns object of formatted time components for the current time,
 * or from a predefined `Date` instance .
 *
 * @param date
 *  Instance of `Date`
 */
function getFormattedTimeComponents(date: Date = new Date())
{
    return  {
        year:  date.getFullYear(),
        month: date.getMonth().toString().padStart(2, '0'),
        day:   date.getDay().toString().padStart(2, '0'),

        hour:  date.getHours().toString().padStart(2, '0'),
        sec:   date.getSeconds().toString().padStart(2, '0'),
        min:   date.getMinutes().toString().padStart(2, '0'),
        ms:    date.getMilliseconds().toString().padStart(3, '0'),
    };
}

/**
 * @TODO(disk0): Do
 * ``` ts
 * const hasChannel: MethodDecorator =
 * function assertLogInstanceChannel(target, propertyKey, descriptor)
 * {
 *   const originalMethod = descriptor.value;
 *
 *   descriptor.value = function (...args) {
 *     if (this.fuel > fuel) {
 *       originalMethod.apply(this, args);
 *     } else {
 *       console.log("Not enough fuel!");
 *     }
 *   };
 *
 *   return descriptor;
 * }
 * ```
 */

/** Losing my mind */
const trace = <T extends AnyFunction>(
    target: Object,
    propertyKey: string | symbol,
    descriptor: TypedPropertyDescriptor<T>
) => {
    /**
     * Display trace message in console if extension `DEBUG` state set, else just return descriptor
     * unchanged
     */
    if(!Object.is(DEBUG, true)) return descriptor;

    let method: NonNullable<typeof descriptor.value> = descriptor.value!
    if(!is.Function(method))
    {
        console.warn(`@trace applied to object with non-function type value.`)
        return descriptor;
        // throw TypeError('Decorated object is not a class instance method, object value is not a function.')
    }

    descriptor.value = (((...args: Parameters<typeof method>): ReturnType<typeof method> =>
    {
        console.debug(`[${META.EXTENSION.NAME}] [Logger] Called Level ${is.String(propertyKey) ? propertyKey : '[SYMBOL]'}`)

        // @TODO: .bind or nah
        return method.bind(target)(...args);
    }) as unknown) as T

    return descriptor
}

//#endregion Utils

export class Logger implements ILogger
{
    #channel!: vscode.OutputChannel;

    constructor(channel: vscode.OutputChannel)
    {
        this.setLoggingChannel(channel)
        this.assertChannel()
    };

    // @trace
    // @bind
    public focus(): void;
    public focus(channel = this.#channel): void
    {
        this.assertChannel(channel)

        channel!.show(true)
    }

    // @trace
    // @bind
    private assertChannel(channel = this.#channel): asserts channel
    {
        if(!channel) throw new Error(OUTPUT.MSG.ERROR.NO_CHANNEL)
    }

    // @trace
    // @bind
    private log = (message: string, level: LogOptions): void =>
    {
        this.assertChannel();

        // Emulate extension host logging format to get highlighting
        // > [2020-09-21 19:45:13.818] [exthost] [warning] TextEditor is closed/disposed

        let _ = getFormattedTimeComponents();

        const timestamp = [
            [ _.year, _.month, _.day ].join('-'),
            [ _.hour, _.min,   _.sec ].join(":") + `.${_.ms}`
        ].join(' ');

        this.#channel!.appendLine( `[${ timestamp }] [${ META.EXTENSION.NAME }] [${ level }] ${ message }` )

        // const dateStr = Date();
        // let [month, , year]    = ( new Date() ).toLocaleDateString().split("/")
        // let [hour, minute, second] = ( new Date() ).toLocaleTimeString().slice(0,7).split(":")

    };

    // @trace
    // @bind
    public info = (message: string): void =>
    {
        this.log(message, LogTypes.info);
    };

    // @trace
    // @bind
    public warn = (message: string): void =>
    {
        this.log(message, LogTypes.warn);
    };

    // @trace
    // @bind
    public error = (message: string): void =>
    {
        this.log(message, LogTypes.error);
    };

    // @trace
    // @bind
    public debug = (message: string): void =>
    {
        if(DEBUG || Settings.getDebug())
            this.log(message, LogTypes.debug)
    }

    // @trace
    @bind
    public setLoggingChannel(channel: vscode.OutputChannel): void
    {
        this.#channel = channel;

        this.info(`live-stylus output channel initialized.`);
    };

    // public tagged(...prefixes: [string, ...string[]])
    /**
     * Creates a single extended logging function
     */
    public tagged = (...prefixes: [string, ...string[]]): TaggedLog =>
    {
        // Normalize prefix items
        prefixes = prefixes.map(prefix => prefix.replace(/^\[|\]$/g, '')) as typeof prefixes

        const taggedLogProps =
        {
            level: 'info' as LogType,
            prefixes,
            prefixTransform()
            {
                return taggedLogProps.prefixes.map(prefix => `[${prefix}]`).join(' ')
            }
        }

        const taggedLogFunction = (msg: string) =>
        {
            instance[taggedLogProps.level]([
                taggedLogProps.prefixTransform(),
                is.String(msg) && msg.length > 0 ? ' ' + msg : ''
            ].join(''))
        }

        return Object.assign(taggedLogFunction,
        ({
            get level() { return taggedLogProps.level },
            set level(newLevel) { taggedLogProps.level = newLevel },

            get prefixes() { return taggedLogProps.prefixes },
            set prefixes(newPrefixes) { taggedLogProps.prefixes = newPrefixes },

            get prefixTransform() { return taggedLogProps.prefixTransform },
            set prefixTransform(newTransform) { taggedLogProps.prefixTransform = newTransform }
        } as TaggedLogProperties))
    }

    /**
     * Creates a new instance with additional namespacing prefixed out log outputs.
     *
     * @TODO Use components of old logger implementation
     */
    // public extend(...scopes: string[]): Logger // LoggerExtend
    // {

    // }
}

/**
 * Default logging instance. For any logging that doesn't require a new
 * output channel.
 */
const instance = new Logger(defaultChannel)

// If debug environment detected open the output panel immediately
if(DEBUG)
{
    instance.focus()
    instance.info(`Verbose output enabled.`)
}

/**
 * Interim wrapper for `tagged` until I migrate functionality to new `Logger`.
 */
export const { tagged }  = instance;

export { instance as log }

export default instance